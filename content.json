{"meta":{"title":"应铎的博客","subtitle":"To strive.","description":"To strive.","author":"应铎","url":"https://YingDuo.github.io"},"pages":[{"title":"404","date":"2018-06-25T10:58:49.000Z","updated":"2018-06-25T10:58:49.179Z","comments":true,"path":"404/index.html","permalink":"https://YingDuo.github.io/404/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-07-03T12:15:35.686Z","updated":"2018-07-03T12:15:35.686Z","comments":false,"path":"tags/index.html","permalink":"https://YingDuo.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-07-03T12:16:27.793Z","updated":"2018-07-03T12:16:27.793Z","comments":false,"path":"categories/index.html","permalink":"https://YingDuo.github.io/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2018-06-25T10:58:38.000Z","updated":"2018-06-25T10:58:38.095Z","comments":true,"path":"search/index.html","permalink":"https://YingDuo.github.io/search/index.html","excerpt":"","text":""}],"posts":[{"title":"mybatis常考面试题","slug":"mybatis常考面试题","date":"2018-08-02T18:06:00.000Z","updated":"2018-08-02T18:06:41.689Z","comments":true,"path":"2018/08/03/mybatis常考面试题/","link":"","permalink":"https://YingDuo.github.io/2018/08/03/mybatis常考面试题/","excerpt":"","text":"网上找的比较全的面试题，今天自己面试时差不多也都问到了，有些细节更底层的地方还要好好挖掘… 1、#{}和${}的区别是什么？ 答：${}是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值，比如ps.setInt(0,parameterValue)，#{item.name}的取值方式为使用反射从参数对象中获取item对象的name属性值，相当于param.getItem().getName()。 2、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？ 答：还有很多其他的标签，、、、、，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中为sql片段标签，通过标签引入sql片段，为不支持自增的主键生成策略标签。 3、最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？ 答：Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个、、、标签，都会被解析为一个MappedStatement对象。 Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。 4、Mybatis是如何进行分页的？分页插件的原理是什么？ 答：Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。 分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。 举例：select from student，拦截sql后重写为：select t. from （select * from student）t limit 0，10 5、简述Mybatis的插件运行原理，以及如何编写一个插件。 答：Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。 实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。 6、Mybatis执行批量插入，能返回数据库主键列表吗？ 答：能，JDBC都能，Mybatis当然也能。 7、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？ 答：Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。 其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。 8、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？ 答：第一种是使用标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。 有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。 9、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。 答：能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。 关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。 那么问题来了，join查询出来100条记录，如何确定主对象是5个，而不是100个？其去重复的原理是标签内的子标签，指定了唯一确定一条记录的id列，Mybatis根据列值来完成100条记录的去重复功能，可以有多个，代表了联合主键的语意。 同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。 举例：下面join查询出来6条记录，一、二列是Teacher对象列，第三列为Student对象列，Mybatis去重复处理后，结果为1个老师6个学生，而不是6个老师6个学生。 1234567 t_id t_name s_id| 1 | teacher | 38 || 1 | teacher | 39 || 1 | teacher | 40 || 1 | teacher | 41 || 1 | teacher | 42 || 1 | teacher | 43 | 10、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？ 答：Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。 它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。 当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。 11、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？ 答：不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。 原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。 12、Mybatis中如何执行批处理？ 答：使用BatchExecutor完成批处理。（个人认为不全面） 13、Mybatis都有哪些Executor执行器？它们之间的区别是什么？ 答：Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。 SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。 ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。 BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。 作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。 14、Mybatis中如何指定使用哪一种Executor执行器？ 答：在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。 15、Mybatis是否可以映射Enum枚举类？ 答：Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。 16、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？ 答：虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。 原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。 17、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？ 答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个、、、标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。 18、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？ 答：Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。 面试题看似都很简单，但是想要能正确回答上来，必定是研究过源码且深入的人，而不是仅会使用的人或者用的很熟的人，以上所有面试题及其答案所涉及的内容，在我的Mybatis系列博客中都有详细讲解和原理分析。","categories":[{"name":"java","slug":"java","permalink":"https://YingDuo.github.io/categories/java/"}],"tags":[{"name":"java框架","slug":"java框架","permalink":"https://YingDuo.github.io/tags/java框架/"}]},{"title":"Object类源码理解","slug":"Object类源码分析","date":"2018-07-23T12:45:00.000Z","updated":"2018-07-23T12:45:53.043Z","comments":true,"path":"2018/07/23/Object类源码分析/","link":"","permalink":"https://YingDuo.github.io/2018/07/23/Object类源码分析/","excerpt":"","text":"今天看Object类源码 首先，Object类是所有类的超类，所有的对象都继承了Object中的方法123456public class Object &#123; private static native void registerNatives(); static &#123; registerNatives(); &#125; 静态代码块在类初始化时必定会执行，所以对象初始化时会调用这个方法。registerNatives含义是本地注册。native表示该方法的实现java本身并没有完成，而是由C++来完成，形成.dll文件。 1public final native Class&lt;?&gt; getClass(); 作用：返回一个运行时类，即获得该类的完整名称 1public native int hashCode(); 也是一个本地方法，返回值是对象的一个哈希值 1.在应用程序执行期间，如果一个对象用于equals()方法的属性没有被修改的话，那么要保证对该对象多次返回的hashcode值要相等。 2.如果2个对象通过equals()方法判断的结果为true，那么要保证二者的hashcode值相等。 3.如果2个对象通过equals()方法判断的结果为false，那么对二者hashcode值是否相等并没有明确要求。如果不相等，那么能够提升散列表的性能。 123public boolean equals(Object obj) &#123; return (this == obj); &#125; 由此我们可以知道，如果没有重写hashcode（）方法和equals（）方法的话，利用“= =”和equals()方法比较的结果是一样的。 “= =”比较的是地址，equals()方法比较的是内容这种说法，是片面的。（虽然在最常用的String类中是这样的） 1protected native Object clone() throws CloneNotSupportedException; 这个也是本地方法。需要注意的是该方法是“浅拷贝”的。 浅拷贝：如果一个对象内部还有一个引用类型的基本变量，那么再拷贝该对象的时候，只是在通过clone方法新产生的新对象中拷贝一个该基本类型的引用。换句话说，也就是新对象和原对象他们内部都含有一个指向同一对象的引用。 深拷贝：拷贝对象的时候，如果对象内部含有一个引用类型类型的变量，那么就会再将该引用类型的变量指向的对象复制一份，然后引用该新对象。 123public String toString() &#123; return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); &#125; 返回信息：运行时类的全名+@+哈希码 123public final native void notify();public final native void notifyAll(); 这两个方法都是本地方法，前者唤醒一个在当前对象监视器上等待的线程。后者唤醒所有在当前对象监视器上等待的线程。 这两个方法应当仅仅被拥有对象监视器的线程所调用。而一个线程成为对象的监视器的拥有者有三种方法： 1.执行该对象上的一个同步方法 2.执行一个同步在对象上的代码块 3.执行该对象的类上的静态同步方法 12345678910111213141516171819202122public final native void wait(long timeout) throws InterruptedException;public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException(\"timeout value is negative\"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout); &#125; public final void wait() throws InterruptedException &#123; wait(0);&#125; 自行理解1protected void finalize() throws Throwable &#123; &#125; 垃圾回收器在认为该对象是垃圾对象的时候会调用该方法。子类可以通过重写该方法来达到资源释放的目的。在方法调用过程中出现的异常会被忽略且方法调用会被终止。任何对象的该方法只会被调用一次。","categories":[{"name":"java","slug":"java","permalink":"https://YingDuo.github.io/categories/java/"}],"tags":[{"name":"javase","slug":"javase","permalink":"https://YingDuo.github.io/tags/javase/"}]},{"title":"java线程与进程，线程的创建和使用","slug":"java线程与进程，线程的创建和使用","date":"2018-07-14T09:31:00.000Z","updated":"2018-07-14T09:32:04.680Z","comments":true,"path":"2018/07/14/java线程与进程，线程的创建和使用/","link":"","permalink":"https://YingDuo.github.io/2018/07/14/java线程与进程，线程的创建和使用/","excerpt":"","text":"进程与线程1.定义进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 2.关系 一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 3.区别 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程。 2) 线程的划分尺度小于进程，使得多线程程序的并发性高。 3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 4.优缺点线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器（多处理器）上运行，而进程则可以跨机器迁移。","categories":[{"name":"java","slug":"java","permalink":"https://YingDuo.github.io/categories/java/"}],"tags":[{"name":"javase","slug":"javase","permalink":"https://YingDuo.github.io/tags/javase/"}]},{"title":"markdown文件中嵌入图片","slug":"markdown文件中嵌入图片","date":"2018-07-10T14:49:00.000Z","updated":"2018-07-10T15:07:34.736Z","comments":true,"path":"2018/07/10/markdown文件中嵌入图片/","link":"","permalink":"https://YingDuo.github.io/2018/07/10/markdown文件中嵌入图片/","excerpt":"","text":"突然想要在markdown中添加图片，可是发现Markdown不像word复制粘贴就好了，网上搜寻之后总结了三种方法 1.插入本地图片在基础语法中添加路径即可，相对路径或者绝对路径均可 1![image](C:\\Users\\应铎\\Pictures\\Saved Pictures\\壁纸) 亲测，没出来 2.插入网络图片基础语法的括号中填入图片的网络链接即可 1![image](http://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=java%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;step_word=&amp;hs=0&amp;pn=0&amp;spn=0&amp;di=31993171430&amp;pi=0&amp;rn=1&amp;tn=baiduimagedetail&amp;is=0%2C0&amp;istype=2&amp;ie=utf-8&amp;oe=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=-1&amp;cs=1937671307%2C314404877&amp;os=306785480%2C220722552&amp;simid=3305791592%2C328878654&amp;adpicid=0&amp;lpn=0&amp;ln=1919&amp;fr=&amp;fmq=1531234802347_R&amp;fm=result&amp;ic=0&amp;s=undefined&amp;se=&amp;sme=&amp;tab=0&amp;width=&amp;height=&amp;face=undefined&amp;ist=&amp;jit=&amp;cg=&amp;bdtype=0&amp;oriquery=&amp;objurl=http%3A%2F%2Fimage82.360doc.com%2FDownloadImg%2F2015%2F02%2F2610%2F50508982_1.jpg&amp;fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z%26e3Bnma15v_z%26e3Bv54AzdH3Fv5gpjgpAzdH3F8cAzdH3FaddmAzdH3F8aAzdH3Fd808d999_9calanln8_z%26e3Bfip4s&amp;gsm=0&amp;rpstart=0&amp;rpnum=0&amp;islist=&amp;querylist=) 还是没出来….. 3.将图片存入Markdown文件用base64转码工具把图片转成一段字符串，然后把字符串填到基础格式中链接的那个位置。 这个时候会发现插入的这一长串字符串会把整个文章分割开，非常影响编写文章时的体验。如果能够把大段的base64字符串放在文章末尾，然后在文章中通过一个id来调用，文章就不会被分割的这么乱了。（尚在学习，未完）","categories":[{"name":"随笔","slug":"随笔","permalink":"https://YingDuo.github.io/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://YingDuo.github.io/tags/随笔/"}]},{"title":"java异常体系","slug":"java异常体系","date":"2018-07-06T10:15:00.000Z","updated":"2018-07-08T13:13:58.215Z","comments":true,"path":"2018/07/06/java异常体系/","link":"","permalink":"https://YingDuo.github.io/2018/07/06/java异常体系/","excerpt":"","text":"一、java异常体系结构1.ThrowableThrowable类是所有错误和异常的超类，有两个子类Error和Exception，分别表示错误和异常。 2.Error与ExceptionError是程序无法处理的错误。Error发生时，java虚拟机一般会选择线程终止Exception是程序自身可以处理的异常，分为两大类：运行时异常和非运行时异常，程序中应当尽可能得去处理这些异常。 3.运行时异常和非运行时异常运行时异常又叫不检查异常，都是RuntimeException类以及其子类异常，程序中可以选择捕获处理，也可以不处理。一般都是由于程序逻辑错误引起，程序应当从逻辑角度尽可能避免这类异常的发生。常见的运行时异常：ArrayIndexOutOfBoundsException数组越界访问，ArrayStoreException数据存储异常，写数组操作时，对象或者数据类型不兼容，ClassCastException类型转换异常，ArithmeticException算术运算中，被0除或模除，OutOfMemoryException内存不足，通常发生于创建对象之时 非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。常见的非运行时异常：IOException、SQLException、用户自定义异常 二、异常的捕获和处理JAVA异常处理涉及到五个关键字，分别是try,catch,finally,throw,throws. 1.异常处理的基本语法1234567try&#123; //尝试运行的程序代码&#125; catch(异常类型 异常的变量名)&#123; //异常处理代码&#125; finally&#123; //异常发生，方法返回之前，总是要执行的代码&#125; try语句块，表示要尝试运行代码，try语句块中的代码受异常监控，其中代码发生异常时，会抛出异常对象 catch语句块会捕获try代码块中发生的异常并在其代码块中做处理，catch语句带一个Throwable类型的参数，表示可捕获异常类型。当try中出现异常时，catch会捕获到发生的异常，并和自己的异常类型匹配，若匹配，则执行catch块中代码，并将catch块参数指向所抛的异常对象。catch语句可以有多个，用来匹配多个中的一个异常，一旦匹配上后，就不再尝试匹配别的catch块了。通过异常对象可以获取异常发生时完整的JVM堆栈信息，以及异常信息和异常发生的原因等。 finally语句块是紧跟catch语句后的语句块，这个语句块总是会在方法返回前执行，而不管try语句块是否发生异常。目的是给程序一个补救的机会，这样做也体现了Java语言的及健壮性。 2.try、catch、finally三个语句块应注意的问题①try、catch、finally三个语句块均不能单独使用。组合形式：try…catch…finally,try…catch,trytry…finally(catch可以有一或多个) ②try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面 ③多个catch块的时候，匹配顺序从上到下，一旦匹配其中一个异常类就执行catch代码，而不会再执行别的catch块 3.throw和throwsthrow关键字是用于方法体内部，用来抛出一个Throwable类型的异常。如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。如果所有方法都层层上抛获取的异常，最终JVM会进行处理。处理也很简单，就是打印异常消息和堆栈信息。如果抛出的是Error或RuntimeException，则该方法的调用者可选择处理该异常 throws关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常。仅当抛出了检查异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常时，应该继续抛出，而不是在catch中打印一下堆栈信息做勉强处理。 1234public static void test() throws Exception&#123; //抛出一个检查异常 throw new Exception(\"方法text（）中的Exception\")；&#125; 4.Throwable类中的常用方法getCause();返回抛出异常的原因，如果cause不存在或未知，返回null。 getMessage():返回异常的消息信息。 printStackTrace():对象的堆栈跟踪输出至错误输出流，作为字段System.err的值。 三、异常处理的一般原则1.能处理就早处理，抛不出去还不能处理的就想法消化掉或者转换为RuntimeException处理。因为对于一个应用系统来说，抛出大量异常是有问题的，应该从程序开发角度尽可能地控制异常发生的可能 2.对于检查异常，如果不能行之有效地处理，还不如转换为RuntimeException抛出。这样也让上层的代码有选择的余地——可处理可不处理。 3.对于一个应用系统来说，应该有自己的一套异常处理框架，也能得到统一的处理风格，将优雅的异常信息反馈给用户 四、异常的转译与异常链1.异常转译的原理异常转译就是将一种异常转换为另一种新的异常，也许这种新的异常更能准确地表达程序发生的异常。在Java中有个概念就是异常原因，异常原因导致当前抛出异常的那个异常对象，几乎所有带异常原因的异常构造方法都使用Throwable类型做参数，这也就为异常的转译提供了直接的支持，因为任何形式的异常和错误都是Throwable的子类。比如将SQLException转换为另外一个新的异常DAOException，可以这么写： 先自定义一个异常DAOException： 123456public class DAOException extends RuntimeException&#123; //省略部分代码 public DAOException(String message, Throwable cause)&#123; super(message, cause); &#125;&#125; 比如有一个SQLException类型的异常对象e，要转换为DAOException，可以这么写： 1DAOException daoEx = new DAOException(“SQL异常”，e); 异常转译是针对所有继承Throwable超类的类而言的，从编程的语法角度讲，其子类之间都可以相互转换。但是，从合理性和系统设计角度考虑，可将异常分为三类：Error、Exception、RuntimeException。 2.异常链异常链顾名思义就是将异常发生的原因一个传一个串起来，即把底层的异常信息传给上层，这样逐层抛出。 例子： 123456try&#123; lowLevelOp();&#125; catch(LowLevelException le)&#123; throw(HighLevelException) new HighLevelException().initCause(le);&#125; 当程序捕获到了一个底层异常le，在处理部分选择了继续抛出一个更高级别的新异常给此方法的调用者。这样异常的原因就会逐层传递。位于高层的异常递归调用getCuse()方法，就可以遍历各层的异常原因。 异常链的实际应用很少，发生异常的时候逐层上抛不是个好主意，上层拿到这些异常又能如何，而且逐层上抛异常会消耗大量资源来保存一个完整地异常链信息。 五、设计一个高效合理地异常处理框架对于一个应用系统来说，发生所有异常在用户看来都是应用系统内部的异常，因此应该设计一套应用系统的异常框架以处理系统运行过程中的所有异常。 方式：用一个自定义异常继承RuntimeException，其他异常转译为该异常，该异常还可以有许多自定义异常子类 by the way， 有关异常框架设计这方面公认比较好的就是Spring，Spring中的所有异常都可以用org.springframework.core.NestedRuntimeException来表示，并且该基类继承的是RuntimeException。Spring框架很庞大，因此设计了很多NestedRuntimeException的子类，还有异常转换的工具，这些都是非常优秀的设计思想。 六、总结1、 异常是程序运行过程过程出现的错误，在Java中用类来描述，用对象来表示具体的异常。Java将其区分为Error与Exception，Error是程序无力处理的错误，Exception是程序可以处理的错误。异常处理是为了程序的健壮性。 2、 Java异常类来自于Java API定义和用户扩展。通过继承Java API异常类可以实现异常的转译。 3、 异常能处理就处理，不能处理就抛出，最终没有处理的异常JVM会进行处理。 4、 异常可以传播，也可以相互转译，但应该根据需要选择合理的异常转译的方向。 5、 对于一个应用系统，设计一套良好的异常处理体系很重要。这一点在系统设计的时候就应该考虑到。","categories":[{"name":"java","slug":"java","permalink":"https://YingDuo.github.io/categories/java/"}],"tags":[{"name":"javase","slug":"javase","permalink":"https://YingDuo.github.io/tags/javase/"}]},{"title":"javaweb写一个登录页面","slug":"javaweb2","date":"2018-07-03T11:41:00.000Z","updated":"2018-07-05T10:08:24.093Z","comments":true,"path":"2018/07/03/javaweb2/","link":"","permalink":"https://YingDuo.github.io/2018/07/03/javaweb2/","excerpt":"","text":"登录页面（动态），要求用户名为张三，密码为12345为成功登录，跳转至成功页面 类：1234567891011121314151617181920212223public class UserServlet extends HttpServlet&#123; private static final long serialVersionUID = 1L; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"UTF-8\"); //取页面的数据 String username =request.getParameter(\"username\").trim(); String upassword = request.getParameter(\"upassword\").trim(); if(username!=null&amp;&amp;!\"\".equals(username)&amp;&amp;upassword!=null&amp;&amp;!\"\".equals(upassword)) &#123; if(\"张三\".equals(username)&amp;&amp;\"12345\".equals(upassword)) &#123; //登录成功 将 用户名放入 request范围 request.setAttribute(\"user\", username); //跳转页面相当于return request.getRequestDispatcher(\"success.jsp\").forward(request, response); &#125; else &#123; request.getRequestDispatcher(\"failure.jsp\").forward(request, response); &#125; &#125;else &#123; request.getRequestDispatcher(\"failure.jsp\").forward(request, response); &#125; &#125;&#125; index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"userServlet\" method=\"post\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; 密码：&lt;input type=\"password\" name=\"upassword\"/&gt;&lt;br/&gt; &lt;button type=\"submit\"&gt;登录&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; web.xml 12345678&lt;servlet&gt; &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;javaweb.UserServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/userServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; success.jsp 1234567891011121314&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%=request.getAttribute(\"user\") %&gt;登录成功！！&lt;% String username = (String)request.getAttribute(\"user\"); out.println(username);%&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"java","slug":"java","permalink":"https://YingDuo.github.io/categories/java/"}],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://YingDuo.github.io/tags/javaweb/"}]},{"title":"第一个javaweb程序，doGet和doPost的区别","slug":"javaweb1","date":"2018-07-02T12:11:00.000Z","updated":"2018-07-05T10:07:49.710Z","comments":true,"path":"2018/07/02/javaweb1/","link":"","permalink":"https://YingDuo.github.io/2018/07/02/javaweb1/","excerpt":"","text":"servlet1234567891011121314151617181920212223242526public class MyServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; // doGet和doPost的区别 // doGet方法可以通过地址栏直接访问 不安全 doPost方法只能通过表单来访问 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"doget\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"doPost\"); // 使用request对象来取页面上的对象 // 转码必须放在第一句 req.setCharacterEncoding(\"UTF-8\"); String username = req.getParameter(\"username\"); String upassword = req.getParameter(\"upassword\"); System.out.println(username); System.out.println(upassword); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://YingDuo.github.io/categories/java/"}],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://YingDuo.github.io/tags/javaweb/"}]},{"title":"First blog","slug":"First-blog","date":"2018-03-19T11:23:02.000Z","updated":"2018-03-19T11:26:40.444Z","comments":true,"path":"2018/03/19/First-blog/","link":"","permalink":"https://YingDuo.github.io/2018/03/19/First-blog/","excerpt":"","text":"你好博客","categories":[],"tags":[]}]}