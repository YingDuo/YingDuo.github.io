{"meta":{"title":"应铎的博客","subtitle":"To strive.","description":"To strive.","author":"应铎","url":"https://YingDuo.github.io"},"pages":[{"title":"404","date":"2018-06-25T10:58:49.000Z","updated":"2018-06-25T10:58:49.179Z","comments":true,"path":"404/index.html","permalink":"https://YingDuo.github.io/404/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-07-03T12:16:27.793Z","updated":"2018-07-03T12:16:27.793Z","comments":false,"path":"categories/index.html","permalink":"https://YingDuo.github.io/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2018-06-25T10:58:38.000Z","updated":"2018-06-25T10:58:38.095Z","comments":true,"path":"search/index.html","permalink":"https://YingDuo.github.io/search/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-07-03T12:15:35.686Z","updated":"2018-07-03T12:15:35.686Z","comments":false,"path":"tags/index.html","permalink":"https://YingDuo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Object类源码理解","slug":"Object类源码分析","date":"2018-07-23T12:45:00.000Z","updated":"2018-07-23T12:45:53.043Z","comments":true,"path":"2018/07/23/Object类源码分析/","link":"","permalink":"https://YingDuo.github.io/2018/07/23/Object类源码分析/","excerpt":"","text":"今天看Object类源码 首先，Object类是所有类的超类，所有的对象都继承了Object中的方法123456public class Object &#123; private static native void registerNatives(); static &#123; registerNatives(); &#125; 静态代码块在类初始化时必定会执行，所以对象初始化时会调用这个方法。registerNatives含义是本地注册。native表示该方法的实现java本身并没有完成，而是由C++来完成，形成.dll文件。 1public final native Class&lt;?&gt; getClass(); 作用：返回一个运行时类，即获得该类的完整名称 1public native int hashCode(); 也是一个本地方法，返回值是对象的一个哈希值 1.在应用程序执行期间，如果一个对象用于equals()方法的属性没有被修改的话，那么要保证对该对象多次返回的hashcode值要相等。 2.如果2个对象通过equals()方法判断的结果为true，那么要保证二者的hashcode值相等。 3.如果2个对象通过equals()方法判断的结果为false，那么对二者hashcode值是否相等并没有明确要求。如果不相等，那么能够提升散列表的性能。 123public boolean equals(Object obj) &#123; return (this == obj); &#125; 由此我们可以知道，如果没有重写hashcode（）方法和equals（）方法的话，利用“= =”和equals()方法比较的结果是一样的。 “= =”比较的是地址，equals()方法比较的是内容这种说法，是片面的。（虽然在最常用的String类中是这样的） 1protected native Object clone() throws CloneNotSupportedException; 这个也是本地方法。需要注意的是该方法是“浅拷贝”的。 浅拷贝：如果一个对象内部还有一个引用类型的基本变量，那么再拷贝该对象的时候，只是在通过clone方法新产生的新对象中拷贝一个该基本类型的引用。换句话说，也就是新对象和原对象他们内部都含有一个指向同一对象的引用。 深拷贝：拷贝对象的时候，如果对象内部含有一个引用类型类型的变量，那么就会再将该引用类型的变量指向的对象复制一份，然后引用该新对象。 123public String toString() &#123; return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); &#125; 返回信息：运行时类的全名+@+哈希码 123public final native void notify();public final native void notifyAll(); 这两个方法都是本地方法，前者唤醒一个在当前对象监视器上等待的线程。后者唤醒所有在当前对象监视器上等待的线程。 这两个方法应当仅仅被拥有对象监视器的线程所调用。而一个线程成为对象的监视器的拥有者有三种方法： 1.执行该对象上的一个同步方法 2.执行一个同步在对象上的代码块 3.执行该对象的类上的静态同步方法 12345678910111213141516171819202122public final native void wait(long timeout) throws InterruptedException;public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException(\"timeout value is negative\"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout); &#125; public final void wait() throws InterruptedException &#123; wait(0);&#125; 自行理解1protected void finalize() throws Throwable &#123; &#125; 垃圾回收器在认为该对象是垃圾对象的时候会调用该方法。子类可以通过重写该方法来达到资源释放的目的。在方法调用过程中出现的异常会被忽略且方法调用会被终止。任何对象的该方法只会被调用一次。","categories":[{"name":"java","slug":"java","permalink":"https://YingDuo.github.io/categories/java/"}],"tags":[{"name":"javase","slug":"javase","permalink":"https://YingDuo.github.io/tags/javase/"}]},{"title":"java线程与进程，线程的创建和使用","slug":"java线程与进程，线程的创建和使用","date":"2018-07-14T09:31:00.000Z","updated":"2018-07-14T09:32:04.680Z","comments":true,"path":"2018/07/14/java线程与进程，线程的创建和使用/","link":"","permalink":"https://YingDuo.github.io/2018/07/14/java线程与进程，线程的创建和使用/","excerpt":"","text":"进程与线程1.定义进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 2.关系 一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 3.区别 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程。 2) 线程的划分尺度小于进程，使得多线程程序的并发性高。 3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 4.优缺点线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器（多处理器）上运行，而进程则可以跨机器迁移。","categories":[{"name":"java","slug":"java","permalink":"https://YingDuo.github.io/categories/java/"}],"tags":[{"name":"javase","slug":"javase","permalink":"https://YingDuo.github.io/tags/javase/"}]},{"title":"markdown文件中嵌入图片","slug":"markdown文件中嵌入图片","date":"2018-07-10T14:49:00.000Z","updated":"2018-07-10T15:07:34.736Z","comments":true,"path":"2018/07/10/markdown文件中嵌入图片/","link":"","permalink":"https://YingDuo.github.io/2018/07/10/markdown文件中嵌入图片/","excerpt":"","text":"突然想要在markdown中添加图片，可是发现Markdown不像word复制粘贴就好了，网上搜寻之后总结了三种方法 1.插入本地图片在基础语法中添加路径即可，相对路径或者绝对路径均可 1![image](C:\\Users\\应铎\\Pictures\\Saved Pictures\\壁纸) 亲测，没出来 2.插入网络图片基础语法的括号中填入图片的网络链接即可 1![image](http://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=java%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;step_word=&amp;hs=0&amp;pn=0&amp;spn=0&amp;di=31993171430&amp;pi=0&amp;rn=1&amp;tn=baiduimagedetail&amp;is=0%2C0&amp;istype=2&amp;ie=utf-8&amp;oe=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=-1&amp;cs=1937671307%2C314404877&amp;os=306785480%2C220722552&amp;simid=3305791592%2C328878654&amp;adpicid=0&amp;lpn=0&amp;ln=1919&amp;fr=&amp;fmq=1531234802347_R&amp;fm=result&amp;ic=0&amp;s=undefined&amp;se=&amp;sme=&amp;tab=0&amp;width=&amp;height=&amp;face=undefined&amp;ist=&amp;jit=&amp;cg=&amp;bdtype=0&amp;oriquery=&amp;objurl=http%3A%2F%2Fimage82.360doc.com%2FDownloadImg%2F2015%2F02%2F2610%2F50508982_1.jpg&amp;fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z%26e3Bnma15v_z%26e3Bv54AzdH3Fv5gpjgpAzdH3F8cAzdH3FaddmAzdH3F8aAzdH3Fd808d999_9calanln8_z%26e3Bfip4s&amp;gsm=0&amp;rpstart=0&amp;rpnum=0&amp;islist=&amp;querylist=) 还是没出来….. 3.将图片存入Markdown文件用base64转码工具把图片转成一段字符串，然后把字符串填到基础格式中链接的那个位置。 这个时候会发现插入的这一长串字符串会把整个文章分割开，非常影响编写文章时的体验。如果能够把大段的base64字符串放在文章末尾，然后在文章中通过一个id来调用，文章就不会被分割的这么乱了。（尚在学习，未完）","categories":[{"name":"随笔","slug":"随笔","permalink":"https://YingDuo.github.io/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://YingDuo.github.io/tags/随笔/"}]},{"title":"java异常体系","slug":"java异常体系","date":"2018-07-06T10:15:00.000Z","updated":"2018-07-08T13:13:58.215Z","comments":true,"path":"2018/07/06/java异常体系/","link":"","permalink":"https://YingDuo.github.io/2018/07/06/java异常体系/","excerpt":"","text":"一、java异常体系结构1.ThrowableThrowable类是所有错误和异常的超类，有两个子类Error和Exception，分别表示错误和异常。 2.Error与ExceptionError是程序无法处理的错误。Error发生时，java虚拟机一般会选择线程终止Exception是程序自身可以处理的异常，分为两大类：运行时异常和非运行时异常，程序中应当尽可能得去处理这些异常。 3.运行时异常和非运行时异常运行时异常又叫不检查异常，都是RuntimeException类以及其子类异常，程序中可以选择捕获处理，也可以不处理。一般都是由于程序逻辑错误引起，程序应当从逻辑角度尽可能避免这类异常的发生。常见的运行时异常：ArrayIndexOutOfBoundsException数组越界访问，ArrayStoreException数据存储异常，写数组操作时，对象或者数据类型不兼容，ClassCastException类型转换异常，ArithmeticException算术运算中，被0除或模除，OutOfMemoryException内存不足，通常发生于创建对象之时 非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。常见的非运行时异常：IOException、SQLException、用户自定义异常 二、异常的捕获和处理JAVA异常处理涉及到五个关键字，分别是try,catch,finally,throw,throws. 1.异常处理的基本语法1234567try&#123; //尝试运行的程序代码&#125; catch(异常类型 异常的变量名)&#123; //异常处理代码&#125; finally&#123; //异常发生，方法返回之前，总是要执行的代码&#125; try语句块，表示要尝试运行代码，try语句块中的代码受异常监控，其中代码发生异常时，会抛出异常对象 catch语句块会捕获try代码块中发生的异常并在其代码块中做处理，catch语句带一个Throwable类型的参数，表示可捕获异常类型。当try中出现异常时，catch会捕获到发生的异常，并和自己的异常类型匹配，若匹配，则执行catch块中代码，并将catch块参数指向所抛的异常对象。catch语句可以有多个，用来匹配多个中的一个异常，一旦匹配上后，就不再尝试匹配别的catch块了。通过异常对象可以获取异常发生时完整的JVM堆栈信息，以及异常信息和异常发生的原因等。 finally语句块是紧跟catch语句后的语句块，这个语句块总是会在方法返回前执行，而不管try语句块是否发生异常。目的是给程序一个补救的机会，这样做也体现了Java语言的及健壮性。 2.try、catch、finally三个语句块应注意的问题①try、catch、finally三个语句块均不能单独使用。组合形式：try…catch…finally,try…catch,trytry…finally(catch可以有一或多个) ②try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面 ③多个catch块的时候，匹配顺序从上到下，一旦匹配其中一个异常类就执行catch代码，而不会再执行别的catch块 3.throw和throwsthrow关键字是用于方法体内部，用来抛出一个Throwable类型的异常。如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。如果所有方法都层层上抛获取的异常，最终JVM会进行处理。处理也很简单，就是打印异常消息和堆栈信息。如果抛出的是Error或RuntimeException，则该方法的调用者可选择处理该异常 throws关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常。仅当抛出了检查异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常时，应该继续抛出，而不是在catch中打印一下堆栈信息做勉强处理。 1234public static void test() throws Exception&#123; //抛出一个检查异常 throw new Exception(\"方法text（）中的Exception\")；&#125; 4.Throwable类中的常用方法getCause();返回抛出异常的原因，如果cause不存在或未知，返回null。 getMessage():返回异常的消息信息。 printStackTrace():对象的堆栈跟踪输出至错误输出流，作为字段System.err的值。 三、异常处理的一般原则1.能处理就早处理，抛不出去还不能处理的就想法消化掉或者转换为RuntimeException处理。因为对于一个应用系统来说，抛出大量异常是有问题的，应该从程序开发角度尽可能地控制异常发生的可能 2.对于检查异常，如果不能行之有效地处理，还不如转换为RuntimeException抛出。这样也让上层的代码有选择的余地——可处理可不处理。 3.对于一个应用系统来说，应该有自己的一套异常处理框架，也能得到统一的处理风格，将优雅的异常信息反馈给用户 四、异常的转译与异常链1.异常转译的原理异常转译就是将一种异常转换为另一种新的异常，也许这种新的异常更能准确地表达程序发生的异常。在Java中有个概念就是异常原因，异常原因导致当前抛出异常的那个异常对象，几乎所有带异常原因的异常构造方法都使用Throwable类型做参数，这也就为异常的转译提供了直接的支持，因为任何形式的异常和错误都是Throwable的子类。比如将SQLException转换为另外一个新的异常DAOException，可以这么写： 先自定义一个异常DAOException： 123456public class DAOException extends RuntimeException&#123; //省略部分代码 public DAOException(String message, Throwable cause)&#123; super(message, cause); &#125;&#125; 比如有一个SQLException类型的异常对象e，要转换为DAOException，可以这么写： 1DAOException daoEx = new DAOException(“SQL异常”，e); 异常转译是针对所有继承Throwable超类的类而言的，从编程的语法角度讲，其子类之间都可以相互转换。但是，从合理性和系统设计角度考虑，可将异常分为三类：Error、Exception、RuntimeException。 2.异常链异常链顾名思义就是将异常发生的原因一个传一个串起来，即把底层的异常信息传给上层，这样逐层抛出。 例子： 123456try&#123; lowLevelOp();&#125; catch(LowLevelException le)&#123; throw(HighLevelException) new HighLevelException().initCause(le);&#125; 当程序捕获到了一个底层异常le，在处理部分选择了继续抛出一个更高级别的新异常给此方法的调用者。这样异常的原因就会逐层传递。位于高层的异常递归调用getCuse()方法，就可以遍历各层的异常原因。 异常链的实际应用很少，发生异常的时候逐层上抛不是个好主意，上层拿到这些异常又能如何，而且逐层上抛异常会消耗大量资源来保存一个完整地异常链信息。 五、设计一个高效合理地异常处理框架对于一个应用系统来说，发生所有异常在用户看来都是应用系统内部的异常，因此应该设计一套应用系统的异常框架以处理系统运行过程中的所有异常。 方式：用一个自定义异常继承RuntimeException，其他异常转译为该异常，该异常还可以有许多自定义异常子类 by the way， 有关异常框架设计这方面公认比较好的就是Spring，Spring中的所有异常都可以用org.springframework.core.NestedRuntimeException来表示，并且该基类继承的是RuntimeException。Spring框架很庞大，因此设计了很多NestedRuntimeException的子类，还有异常转换的工具，这些都是非常优秀的设计思想。 六、总结1、 异常是程序运行过程过程出现的错误，在Java中用类来描述，用对象来表示具体的异常。Java将其区分为Error与Exception，Error是程序无力处理的错误，Exception是程序可以处理的错误。异常处理是为了程序的健壮性。 2、 Java异常类来自于Java API定义和用户扩展。通过继承Java API异常类可以实现异常的转译。 3、 异常能处理就处理，不能处理就抛出，最终没有处理的异常JVM会进行处理。 4、 异常可以传播，也可以相互转译，但应该根据需要选择合理的异常转译的方向。 5、 对于一个应用系统，设计一套良好的异常处理体系很重要。这一点在系统设计的时候就应该考虑到。","categories":[{"name":"java","slug":"java","permalink":"https://YingDuo.github.io/categories/java/"}],"tags":[{"name":"javase","slug":"javase","permalink":"https://YingDuo.github.io/tags/javase/"}]},{"title":"javaweb写一个登录页面","slug":"javaweb2","date":"2018-07-03T11:41:00.000Z","updated":"2018-07-05T10:08:24.093Z","comments":true,"path":"2018/07/03/javaweb2/","link":"","permalink":"https://YingDuo.github.io/2018/07/03/javaweb2/","excerpt":"","text":"登录页面（动态），要求用户名为张三，密码为12345为成功登录，跳转至成功页面 类：1234567891011121314151617181920212223public class UserServlet extends HttpServlet&#123; private static final long serialVersionUID = 1L; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"UTF-8\"); //取页面的数据 String username =request.getParameter(\"username\").trim(); String upassword = request.getParameter(\"upassword\").trim(); if(username!=null&amp;&amp;!\"\".equals(username)&amp;&amp;upassword!=null&amp;&amp;!\"\".equals(upassword)) &#123; if(\"张三\".equals(username)&amp;&amp;\"12345\".equals(upassword)) &#123; //登录成功 将 用户名放入 request范围 request.setAttribute(\"user\", username); //跳转页面相当于return request.getRequestDispatcher(\"success.jsp\").forward(request, response); &#125; else &#123; request.getRequestDispatcher(\"failure.jsp\").forward(request, response); &#125; &#125;else &#123; request.getRequestDispatcher(\"failure.jsp\").forward(request, response); &#125; &#125;&#125; index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"userServlet\" method=\"post\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; 密码：&lt;input type=\"password\" name=\"upassword\"/&gt;&lt;br/&gt; &lt;button type=\"submit\"&gt;登录&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; web.xml 12345678&lt;servlet&gt; &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;javaweb.UserServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/userServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; success.jsp 1234567891011121314&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%=request.getAttribute(\"user\") %&gt;登录成功！！&lt;% String username = (String)request.getAttribute(\"user\"); out.println(username);%&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"java","slug":"java","permalink":"https://YingDuo.github.io/categories/java/"}],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://YingDuo.github.io/tags/javaweb/"}]},{"title":"第一个javaweb程序，doGet和doPost的区别","slug":"javaweb1","date":"2018-07-02T12:11:00.000Z","updated":"2018-07-05T10:07:49.710Z","comments":true,"path":"2018/07/02/javaweb1/","link":"","permalink":"https://YingDuo.github.io/2018/07/02/javaweb1/","excerpt":"","text":"servlet1234567891011121314151617181920212223242526public class MyServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; // doGet和doPost的区别 // doGet方法可以通过地址栏直接访问 不安全 doPost方法只能通过表单来访问 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"doget\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"doPost\"); // 使用request对象来取页面上的对象 // 转码必须放在第一句 req.setCharacterEncoding(\"UTF-8\"); String username = req.getParameter(\"username\"); String upassword = req.getParameter(\"upassword\"); System.out.println(username); System.out.println(upassword); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://YingDuo.github.io/categories/java/"}],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://YingDuo.github.io/tags/javaweb/"}]},{"title":"First blog","slug":"First-blog","date":"2018-03-19T11:23:02.000Z","updated":"2018-03-19T11:26:40.444Z","comments":true,"path":"2018/03/19/First-blog/","link":"","permalink":"https://YingDuo.github.io/2018/03/19/First-blog/","excerpt":"","text":"你好博客","categories":[],"tags":[]}]}