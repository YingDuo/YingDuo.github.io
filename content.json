{"meta":{"title":"YD","subtitle":"To strive.","description":"To strive.","author":"应铎","url":"https://YingDuo.github.io"},"pages":[{"title":"404","date":"2018-06-25T10:58:49.000Z","updated":"2018-06-25T10:58:49.179Z","comments":true,"path":"404/index.html","permalink":"https://YingDuo.github.io/404/index.html","excerpt":"","text":""},{"title":"search","date":"2018-06-25T10:58:38.000Z","updated":"2018-06-25T10:58:38.095Z","comments":true,"path":"search/index.html","permalink":"https://YingDuo.github.io/search/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-07-03T12:15:35.686Z","updated":"2018-07-03T12:15:35.686Z","comments":false,"path":"tags/index.html","permalink":"https://YingDuo.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-07-03T12:16:27.793Z","updated":"2018-07-03T12:16:27.793Z","comments":false,"path":"categories/index.html","permalink":"https://YingDuo.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"java异常体系","slug":"java异常体系","date":"2018-07-06T10:15:00.000Z","updated":"2018-07-08T13:13:58.215Z","comments":true,"path":"2018/07/06/java异常体系/","link":"","permalink":"https://YingDuo.github.io/2018/07/06/java异常体系/","excerpt":"","text":"一、java异常体系结构1.ThrowableThrowable类是所有错误和异常的超类，有两个子类Error和Exception，分别表示错误和异常。 2.Error与ExceptionError是程序无法处理的错误。Error发生时，java虚拟机一般会选择线程终止Exception是程序自身可以处理的异常，分为两大类：运行时异常和非运行时异常，程序中应当尽可能得去处理这些异常。 3.运行时异常和非运行时异常运行时异常又叫不检查异常，都是RuntimeException类以及其子类异常，程序中可以选择捕获处理，也可以不处理。一般都是由于程序逻辑错误引起，程序应当从逻辑角度尽可能避免这类异常的发生。常见的运行时异常：ArrayIndexOutOfBoundsException数组越界访问，ArrayStoreException数据存储异常，写数组操作时，对象或者数据类型不兼容，ClassCastException类型转换异常，ArithmeticException算术运算中，被0除或模除，OutOfMemoryException内存不足，通常发生于创建对象之时 非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。常见的非运行时异常：IOException、SQLException、用户自定义异常 二、异常的捕获和处理JAVA异常处理涉及到五个关键字，分别是try,catch,finally,throw,throws. 1.异常处理的基本语法1234567try&#123; //尝试运行的程序代码&#125; catch(异常类型 异常的变量名)&#123; //异常处理代码&#125; finally&#123; //异常发生，方法返回之前，总是要执行的代码&#125; try语句块，表示要尝试运行代码，try语句块中的代码受异常监控，其中代码发生异常时，会抛出异常对象 catch语句块会捕获try代码块中发生的异常并在其代码块中做处理，catch语句带一个Throwable类型的参数，表示可捕获异常类型。当try中出现异常时，catch会捕获到发生的异常，并和自己的异常类型匹配，若匹配，则执行catch块中代码，并将catch块参数指向所抛的异常对象。catch语句可以有多个，用来匹配多个中的一个异常，一旦匹配上后，就不再尝试匹配别的catch块了。通过异常对象可以获取异常发生时完整的JVM堆栈信息，以及异常信息和异常发生的原因等。 finally语句块是紧跟catch语句后的语句块，这个语句块总是会在方法返回前执行，而不管try语句块是否发生异常。目的是给程序一个补救的机会，这样做也体现了Java语言的及健壮性。 2.try、catch、finally三个语句块应注意的问题①try、catch、finally三个语句块均不能单独使用。组合形式：try…catch…finally,try…catch,trytry…finally(catch可以有一或多个) ②try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面 ③多个catch块的时候，匹配顺序从上到下，一旦匹配其中一个异常类就执行catch代码，而不会再执行别的catch块 3.throw和throwsthrow关键字是用于方法体内部，用来抛出一个Throwable类型的异常。如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。如果所有方法都层层上抛获取的异常，最终JVM会进行处理。处理也很简单，就是打印异常消息和堆栈信息。如果抛出的是Error或RuntimeException，则该方法的调用者可选择处理该异常 throws关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常。仅当抛出了检查异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常时，应该继续抛出，而不是在catch中打印一下堆栈信息做勉强处理。 1234public static void test() throws Exception&#123; //抛出一个检查异常 throw new Exception(\"方法text（）中的Exception\")；&#125; 4.Throwable类中的常用方法getCause();返回抛出异常的原因，如果cause不存在或未知，返回null。 getMessage():返回异常的消息信息。 printStackTrace():对象的堆栈跟踪输出至错误输出流，作为字段System.err的值。 三、异常处理的一般原则1.能处理就早处理，抛不出去还不能处理的就想法消化掉或者转换为RuntimeException处理。因为对于一个应用系统来说，抛出大量异常是有问题的，应该从程序开发角度尽可能地控制异常发生的可能 2.对于检查异常，如果不能行之有效地处理，还不如转换为RuntimeException抛出。这样也让上层的代码有选择的余地——可处理可不处理。 3.对于一个应用系统来说，应该有自己的一套异常处理框架，也能得到统一的处理风格，将优雅的异常信息反馈给用户 四、异常的转译与异常链1.异常转译的原理异常转译就是将一种异常转换为另一种新的异常，也许这种新的异常更能准确地表达程序发生的异常。在Java中有个概念就是异常原因，异常原因导致当前抛出异常的那个异常对象，几乎所有带异常原因的异常构造方法都使用Throwable类型做参数，这也就为异常的转译提供了直接的支持，因为任何形式的异常和错误都是Throwable的子类。比如将SQLException转换为另外一个新的异常DAOException，可以这么写： 先自定义一个异常DAOException： 123456public class DAOException extends RuntimeException&#123; //省略部分代码 public DAOException(String message, Throwable cause)&#123; super(message, cause); &#125;&#125; 比如有一个SQLException类型的异常对象e，要转换为DAOException，可以这么写： 1DAOException daoEx = new DAOException(“SQL异常”，e); 异常转译是针对所有继承Throwable超类的类而言的，从编程的语法角度讲，其子类之间都可以相互转换。但是，从合理性和系统设计角度考虑，可将异常分为三类：Error、Exception、RuntimeException。 2.异常链异常链顾名思义就是将异常发生的原因一个传一个串起来，即把底层的异常信息传给上层，这样逐层抛出。 例子： 123456try&#123; lowLevelOp();&#125; catch(LowLevelException le)&#123; throw(HighLevelException) new HighLevelException().initCause(le);&#125; 当程序捕获到了一个底层异常le，在处理部分选择了继续抛出一个更高级别的新异常给此方法的调用者。这样异常的原因就会逐层传递。位于高层的异常递归调用getCuse()方法，就可以遍历各层的异常原因。 异常链的实际应用很少，发生异常的时候逐层上抛不是个好主意，上层拿到这些异常又能如何，而且逐层上抛异常会消耗大量资源来保存一个完整地异常链信息。 五、设计一个高效合理地异常处理框架对于一个应用系统来说，发生所有异常在用户看来都是应用系统内部的异常，因此应该设计一套应用系统的异常框架以处理系统运行过程中的所有异常。 方式：用一个自定义异常继承RuntimeException，其他异常转译为该异常，该异常还可以有许多自定义异常子类 by the way， 有关异常框架设计这方面公认比较好的就是Spring，Spring中的所有异常都可以用org.springframework.core.NestedRuntimeException来表示，并且该基类继承的是RuntimeException。Spring框架很庞大，因此设计了很多NestedRuntimeException的子类，还有异常转换的工具，这些都是非常优秀的设计思想。 六、总结1、 异常是程序运行过程过程出现的错误，在Java中用类来描述，用对象来表示具体的异常。Java将其区分为Error与Exception，Error是程序无力处理的错误，Exception是程序可以处理的错误。异常处理是为了程序的健壮性。 2、 Java异常类来自于Java API定义和用户扩展。通过继承Java API异常类可以实现异常的转译。 3、 异常能处理就处理，不能处理就抛出，最终没有处理的异常JVM会进行处理。 4、 异常可以传播，也可以相互转译，但应该根据需要选择合理的异常转译的方向。 5、 对于一个应用系统，设计一套良好的异常处理体系很重要。这一点在系统设计的时候就应该考虑到。","categories":[{"name":"java","slug":"java","permalink":"https://YingDuo.github.io/categories/java/"}],"tags":[{"name":"javase","slug":"javase","permalink":"https://YingDuo.github.io/tags/javase/"}]},{"title":"javaweb写一个登录页面","slug":"javaweb2","date":"2018-07-03T11:41:00.000Z","updated":"2018-07-05T10:08:24.093Z","comments":true,"path":"2018/07/03/javaweb2/","link":"","permalink":"https://YingDuo.github.io/2018/07/03/javaweb2/","excerpt":"","text":"登录页面（动态），要求用户名为张三，密码为12345为成功登录，跳转至成功页面 类：1234567891011121314151617181920212223public class UserServlet extends HttpServlet&#123; private static final long serialVersionUID = 1L; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"UTF-8\"); //取页面的数据 String username =request.getParameter(\"username\").trim(); String upassword = request.getParameter(\"upassword\").trim(); if(username!=null&amp;&amp;!\"\".equals(username)&amp;&amp;upassword!=null&amp;&amp;!\"\".equals(upassword)) &#123; if(\"张三\".equals(username)&amp;&amp;\"12345\".equals(upassword)) &#123; //登录成功 将 用户名放入 request范围 request.setAttribute(\"user\", username); //跳转页面相当于return request.getRequestDispatcher(\"success.jsp\").forward(request, response); &#125; else &#123; request.getRequestDispatcher(\"failure.jsp\").forward(request, response); &#125; &#125;else &#123; request.getRequestDispatcher(\"failure.jsp\").forward(request, response); &#125; &#125;&#125; index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"userServlet\" method=\"post\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; 密码：&lt;input type=\"password\" name=\"upassword\"/&gt;&lt;br/&gt; &lt;button type=\"submit\"&gt;登录&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; web.xml 12345678&lt;servlet&gt; &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;javaweb.UserServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/userServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; success.jsp 1234567891011121314&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%=request.getAttribute(\"user\") %&gt;登录成功！！&lt;% String username = (String)request.getAttribute(\"user\"); out.println(username);%&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"java","slug":"java","permalink":"https://YingDuo.github.io/categories/java/"}],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://YingDuo.github.io/tags/javaweb/"}]},{"title":"第一个javaweb程序，doGet和doPost的区别","slug":"javaweb1","date":"2018-07-02T12:11:00.000Z","updated":"2018-07-05T10:07:49.710Z","comments":true,"path":"2018/07/02/javaweb1/","link":"","permalink":"https://YingDuo.github.io/2018/07/02/javaweb1/","excerpt":"","text":"servlet1234567891011121314151617181920212223242526public class MyServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; // doGet和doPost的区别 // doGet方法可以通过地址栏直接访问 不安全 doPost方法只能通过表单来访问 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"doget\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"doPost\"); // 使用request对象来取页面上的对象 // 转码必须放在第一句 req.setCharacterEncoding(\"UTF-8\"); String username = req.getParameter(\"username\"); String upassword = req.getParameter(\"upassword\"); System.out.println(username); System.out.println(upassword); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://YingDuo.github.io/categories/java/"}],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://YingDuo.github.io/tags/javaweb/"}]},{"title":"First blog","slug":"First-blog","date":"2018-03-19T11:23:02.000Z","updated":"2018-03-19T11:26:40.444Z","comments":true,"path":"2018/03/19/First-blog/","link":"","permalink":"https://YingDuo.github.io/2018/03/19/First-blog/","excerpt":"","text":"你好博客","categories":[],"tags":[]}]}